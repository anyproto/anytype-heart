//go:build !cshared

// bridge/generate.go
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
)

func main() {
	// Path to the service package
	servicePath := "../service"

	// Create file set
	fset := token.NewFileSet()

	// Parse the package
	pkgs, err := parser.ParseDir(fset, servicePath, nil, 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing package: %v\n", err)
		os.Exit(1)
	}

	// Open the output file
	f, err := os.Create("export_generated.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	// Write package header
	fmt.Fprintln(f, "// Code generated by go generate; DO NOT EDIT.")
	fmt.Fprintln(f, "//go:build cshared")
	fmt.Fprintln(f, "package main")
	fmt.Fprintln(f)
	fmt.Fprintln(f, `/*
#include <stdlib.h>
*/`)
	fmt.Fprintln(f, `import "C"`)
	fmt.Fprintln(f, `import (
	"unsafe"
	
	"github.com/anyproto/anytype-heart/clientlibrary/service"
)`)
	fmt.Fprintln(f)

	// Process each function
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			for name, obj := range file.Scope.Objects {
				if obj.Kind != ast.Fun {
					continue
				}

				// Check if function has the right signature ([]byte) []byte
				funcDecl, ok := obj.Decl.(*ast.FuncDecl)
				if !ok {
					continue
				}

				// Skip non-exported functions
				if !funcDecl.Name.IsExported() {
					continue
				}

				// Check function signature
				if isRpcFunction(funcDecl) {
					// Generate an export function for this service function
					generateExportFunc(f, name)
				}
			}
		}
	}

	// Add FreeBuf function
	fmt.Fprintln(f, `//export FreeBuf
func FreeBuf(buf *C.uchar) {
	C.free(unsafe.Pointer(buf))
}`)

	// Add main function
	fmt.Fprintln(f, `
func main() {
	// This function is required but not used when building as a shared library
}`)
}

// Generate an export function for the given service function
func generateExportFunc(f *os.File, funcName string) {
	exportName := funcName

	// Write the export function
	fmt.Fprintf(f, `//export %s
func %s(in *C.uchar, inLen C.int, outLen *C.int) *C.uchar {
	req := C.GoBytes(unsafe.Pointer(in), inLen)
	resp := service.%s(req)
	
	*outLen = C.int(len(resp))
	return (*C.uchar)(C.CBytes(resp)) // malloc-ed with C.malloc
}

`, exportName, exportName, funcName)
}

// Check if a function has the signature ([]byte) []byte
func isRpcFunction(funcDecl *ast.FuncDecl) bool {
	// Must have one parameter and one return value
	params := funcDecl.Type.Params.List
	results := funcDecl.Type.Results

	if len(params) != 1 || results == nil || len(results.List) != 1 {
		return false
	}

	// Parameter must be []byte
	param := params[0]
	paramType, ok := param.Type.(*ast.ArrayType)
	if !ok || paramType.Len != nil {
		return false
	}

	paramElt, ok := paramType.Elt.(*ast.Ident)
	if !ok || paramElt.Name != "byte" {
		return false
	}

	// Return value must be []byte
	result := results.List[0]
	resultType, ok := result.Type.(*ast.ArrayType)
	if !ok || resultType.Len != nil {
		return false
	}

	resultElt, ok := resultType.Elt.(*ast.Ident)
	if !ok || resultElt.Name != "byte" {
		return false
	}

	return true
}
