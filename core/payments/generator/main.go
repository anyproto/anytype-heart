package main

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"

	proto "github.com/anyproto/any-sync/paymentservice/paymentserviceproto"
	"gopkg.in/yaml.v3"

	"github.com/anyproto/anytype-heart/pkg/lib/pb/model"
)

type Config struct {
	Conversions []Conversion `yaml:"conversions"`
}

type Conversion struct {
	Name     string         `yaml:"name"`
	Source   TypeRef        `yaml:"source"`
	Target   TypeRef        `yaml:"target"`
	Imports  []Import       `yaml:"imports"`
	Mappings map[string]any `yaml:"mappings"`
}

type TypeRef struct {
	Package string `yaml:"package"`
	Type    string `yaml:"type"`
	Alias   string `yaml:"alias"`
}

type Import struct {
	Path  string `yaml:"path"`
	Alias string `yaml:"alias"`
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Read config
	configData, err := os.ReadFile(filepath.Join("generator", "config.yaml"))
	if err != nil {
		return fmt.Errorf("failed to read config: %w", err)
	}

	var config Config
	if err := yaml.Unmarshal(configData, &config); err != nil {
		return fmt.Errorf("failed to parse config: %w", err)
	}

	// Generate code for each conversion
	for _, conv := range config.Conversions {
		if err := generateConversion(conv); err != nil {
			return fmt.Errorf("failed to generate %s: %w", conv.Name, err)
		}
	}

	return nil
}

func generateConversion(conv Conversion) error {
	// Get struct types using reflection
	sourceType := getType(conv.Source.Type)
	targetType := getType(conv.Target.Type)

	if sourceType == nil || targetType == nil {
		return fmt.Errorf("could not resolve types")
	}

	// Build assignments
	assignments := buildAssignments(sourceType, targetType, conv.Mappings)

	// Generate code
	return generateCode(conv, assignments)
}

func getType(typeName string) reflect.Type {
	// Map type names to actual types
	typeMap := map[string]reflect.Type{
		"TierData":                reflect.TypeOf(&proto.TierData{}).Elem(),
		"MembershipTierData":      reflect.TypeOf(&model.MembershipTierData{}).Elem(),
		"GetSubscriptionResponse": reflect.TypeOf(&proto.GetSubscriptionResponse{}).Elem(),
		"Membership":              reflect.TypeOf(&model.Membership{}).Elem(),
	}
	return typeMap[typeName]
}

type Assignment struct {
	TargetField string
	SourceField string
	Code        string // Generated assignment code
	IsCustom    bool   // True if this is a custom code block
}

func buildAssignments(sourceType, targetType reflect.Type, mappings map[string]any) []Assignment {
	var assignments []Assignment
	customCode := make(map[string]string)
	transforms := make(map[string]string)

	// Parse mappings
	for field, mapping := range mappings {
		switch m := mapping.(type) {
		case map[string]any:
			if transform, ok := m["transform"].(string); ok {
				transforms[field] = transform
			}
			if custom, ok := m["custom"].(string); ok {
				customCode[field] = custom
			}
		}
	}

	// Build list of fields to skip (handled by custom code)
	skipFields := make(map[string]bool)
	for field := range customCode {
		skipFields[field] = true
	}
	// Also skip NsNameType if NsName has custom code (they're set together)
	if _, ok := customCode["NsName"]; ok {
		skipFields["NsNameType"] = true
	}

	// Match fields
	for i := 0; i < targetType.NumField(); i++ {
		targetField := targetType.Field(i)
		targetName := targetField.Name

		// Skip if there's custom code for this field
		if skipFields[targetName] {
			continue
		}

		// Check if source has matching field
		sourceField, found := sourceType.FieldByName(targetName)
		if !found {
			continue
		}

		var code string
		if transform, ok := transforms[targetName]; ok {
			// Use transformation
			code = strings.ReplaceAll(transform, "src.", "src.")
		} else {
			// Direct assignment
			code = fmt.Sprintf("src.%s", sourceField.Name)
		}

		assignments = append(assignments, Assignment{
			TargetField: targetName,
			SourceField: sourceField.Name,
			Code:        code,
		})
	}

	// Add custom code blocks
	for field, code := range customCode {
		assignments = append(assignments, Assignment{
			TargetField: field,
			Code:        strings.TrimSpace(code),
			IsCustom:    true,
		})
	}

	return assignments
}

func generateCode(conv Conversion, assignments []Assignment) error {
	// Build import statements from config
	var importLines []string
	for _, imp := range conv.Imports {
		if imp.Alias != "" {
			importLines = append(importLines, fmt.Sprintf("\t%s \"%s\"", imp.Alias, imp.Path))
		} else {
			importLines = append(importLines, fmt.Sprintf("\t\"%s\"", imp.Path))
		}
	}
	imports := strings.Join(importLines, "\n")

	tmpl := `// Code generated by go generate; DO NOT EDIT.
// To regenerate: go generate ./core/payments/...

package payments

import (
{{.Imports}}
)

func {{.Name}}(src *proto.{{.SourceType}}) *model.{{.TargetType}} {
	out := &model.{{.TargetType}}{}
	{{range .Assignments}}
	{{- if .IsCustom}}
	// {{.TargetField}} - custom mapping
	{{.Code}}
	{{- else}}
	out.{{.TargetField}} = {{.Code}}
	{{- end}}
	{{end}}
	return out
}
`

	funcMap := template.FuncMap{
		"contains": strings.Contains,
	}

	t, err := template.New("converter").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return err
	}

	data := struct {
		Name        string
		SourceType  string
		TargetType  string
		Assignments []Assignment
		Imports     string
	}{
		Name:        conv.Name,
		SourceType:  conv.Source.Type,
		TargetType:  conv.Target.Type,
		Assignments: assignments,
		Imports:     imports,
	}

	outputPath := fmt.Sprintf("./%s_gen.go", conv.Name)
	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Printf("Generating %s...\n", outputPath)
	return t.Execute(f, data)
}
