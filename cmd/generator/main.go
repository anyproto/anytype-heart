package main

// Package generator provides utilities for generating OpenAI tools from OpenAPI specifications.
//
// Usage as a library:
//
//	// Load OpenAPI spec
//	spec, err := generator.LoadSpec("path/to/swagger.yaml")
//	if err != nil {
//		log.Fatal(err)
//	}
//
//	// Generate all tools
//	toolsInfo, err := generator.GenerateTools(spec)
//	if err != nil {
//		log.Fatal(err)
//	}
//
//	// Get schema for a specific endpoint
//	schema, err := generator.GetEndpointSchema("endpoint_name")
//	if err != nil {
//		log.Fatal(err)
//	}
//
//	// Create a tool from a schema
//	tool := generator.CreateTool("tool_name", "description", schema)
//
//	// Get a tool for a specific endpoint
//	tool, err := generator.GetTool("endpoint_name")
//	if err != nil {
//		log.Fatal(err)
//	}

// openAI tool generator from openAPI yaml
import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/anyproto/anytype-heart/cmd/generator/generator"
)

// Package can be reused as a library for generating OpenAI tools
// from OpenAPI specs and getting schemas programmatically.

func main() {
	// Load your local Swagger/OpenAPI spec
	// run from the root of the project
	spec, err := generator.LoadSpec("core/api/docs/swagger.yaml")
	if err != nil {
		log.Fatalf("failed to load spec: %v", err)
	}

	// Generate tools from the spec
	toolsInfo, err := generator.GenerateTools(spec)
	if err != nil {
		log.Fatalf("failed to generate tools: %v", err)
	}

	// Ensure the directory exists
	outputDir := "cmd/assistant/api"
	err = os.MkdirAll(outputDir, 0755)
	if err != nil {
		log.Fatalf("failed to create output directory: %v", err)
	}

	// Open the output file
	outputPath := filepath.Join(outputDir, "tools.gen.go")
	file, err := os.Create(outputPath)
	if err != nil {
		log.Fatalf("failed to create output file: %v", err)
	}
	defer file.Close()

	// Write package declaration and imports
	fmt.Fprintln(file, "// Code generated by generator; DO NOT EDIT.")
	fmt.Fprintln(file, "package api")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "import (")
	fmt.Fprintln(file, "\t\"encoding/json\"")
	fmt.Fprintln(file, "\t\"github.com/sashabaranov/go-openai\"")
	fmt.Fprintln(file, ")")
	fmt.Fprintln(file, "")

	// Define ApiTool struct
	fmt.Fprintln(file, "// ApiTool wraps an OpenAI tool with API endpoint information")
	fmt.Fprintln(file, "type ApiTool struct {")
	fmt.Fprintln(file, "\topenai.Tool")
	fmt.Fprintln(file, "\tMethod string")
	fmt.Fprintln(file, "\tPath   string")
	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")

	// Write tools variable declaration
	fmt.Fprintln(file, "// AnytypeTools is a generated list of tools based on the OpenAPI spec")
	fmt.Fprintln(file, "var AnytypeTools = []ApiTool{")

	// Write each tool with its endpoint info
	for i, toolInfo := range toolsInfo {
		fmt.Fprintf(file, "\t{\n\t\tTool: openai.Tool{\n\t\t\tType: openai.ToolTypeFunction,\n\t\t\tFunction: &openai.FunctionDefinition{\n\t\t\t\tName: %q,\n\t\t\t\tDescription: %q,\n",
			toolInfo.Tool.Function.Name,
			toolInfo.Tool.Function.Description)

		// Handle parameters as JSON string
		paramBytes, _ := json.Marshal(toolInfo.Tool.Function.Parameters)
		fmt.Fprintf(file, "\t\t\t\tParameters: json.RawMessage(`%s`),\n\t\t\t},\n\t\t},\n", string(paramBytes))

		// Add endpoint info
		fmt.Fprintf(file, "\t\tMethod: %q,\n\t\tPath: %q,\n\t}", toolInfo.Method, toolInfo.Path)

		if i < len(toolsInfo)-1 {
			fmt.Fprintln(file, ",")
		} else {
			fmt.Fprintln(file, "")
		}
	}
	fmt.Fprintln(file, "}")

	// Add helper to get just the OpenAI tools
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "// GetOpenAITools returns just the OpenAI tool definitions without the API info")
	fmt.Fprintln(file, "func GetOpenAITools() []openai.Tool {")
	fmt.Fprintln(file, "\ttools := make([]openai.Tool, len(AnytypeTools))")
	fmt.Fprintln(file, "\tfor i, t := range AnytypeTools {")
	fmt.Fprintln(file, "\t\ttools[i] = t.Tool")
	fmt.Fprintln(file, "\t}")
	fmt.Fprintln(file, "\treturn tools")
	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")

	// Add helper to get tool by name
	fmt.Fprintln(file, "// GetToolByName returns an ApiTool by its name")
	fmt.Fprintln(file, "func GetToolByName(name string) *ApiTool {")
	fmt.Fprintln(file, "\tfor i := range AnytypeTools {")
	fmt.Fprintln(file, "\t\tif AnytypeTools[i].Function.Name == name {")
	fmt.Fprintln(file, "\t\t\treturn &AnytypeTools[i]")
	fmt.Fprintln(file, "\t\t}")
	fmt.Fprintln(file, "\t}")
	fmt.Fprintln(file, "\treturn nil")
	fmt.Fprintln(file, "}")

	fmt.Printf("Generated tools with endpoint mapping written to %s\n", outputPath)
}
